---
typora-copy-images-to: upload
---

# Java学习笔记

## Day01

1. JDK(Java开发环境)、JRE(Java运行环境)

2. HelloWorld

   ```Java
   package Day2;
   
   public class HelloWorld {
       //叫做main的方法，表示程序的主入口
       public static void main(String[] agrs){
           /*
           叫做输出语句，会把小括号里面的内容打印出来
            */
           System.out.println("Hello, World");
       }
   }
   
   ```

   

## Day02

1.注释（解释说明）与关键字（被Java赋予了特定含义的英文单词）

**class**:用于（创建/定义）一个类，后面跟随类名，类是JAVA最基本的组成单元

2.字面量

告诉程序员：数据在程序中的书写格式

3.变量

数据类型 变量名 = 数据值

1）输出打印 

2）参与计算 

3）修改变量记录的值

注意事项：1.一行语句可以定义多个变量

​					2.变量在使用之前必须要赋值

​					3.变量名不能重复

4.数据类型

长度（从小到大）：byte-->short--> int -->long -->float--> double

分为基本数据类型、引用数据类型，共四类八种

整数、浮点数、字符、布尔

long类型变量需要加上L标识（大小写都可以）

float类型变量需要加入F标识（大小写都可以）

5 .标识符

就是给类，方法，变量等起的名字

命名规则：由数字、字母、下划线和美元符号组成；不能以数字开头；不能是关键字

6.键盘录入

Scanner类可以接收键盘输入的数字



  ## Day03

1. 运算符


在代码中如果有小数参与计算，结果有可能不精确.

数字进行运算时，数据类型不一样是不能进行运算的，需要转换为同一种数据类型，才能运算。

**类型转换**

隐式转换（自动类型提升）：两种提升规则

1）取值范围小的和取值范围大的进行运算，小的会先提升为大的，再进行运算。

2）byte short char 三种类型的数据在运算的时候，都会直接先提升为int，然后再进行运算

**强制转换**

如果把一个取值范围大的数值，赋值给取值范围小的变量，是不允许直接赋值的。如果一定要这么做就需要加入强制转换。

格式： 目标数据类型 变量名 = （目标数据类型）被强转的数据

2. 自增自减运算符

   ++和-- ，单独写一行结果是一样的。

   参与计算：**后++**：先用后加，**前++**：先加后用

3. 算术运算符、逻辑运算符

   短路逻辑运算符：&& 、|| ，当左边的表达式能确定最终的结果，那么右边就不会参与运行了 

4. 三元运算符

   可以进行判断，根据判断的结果得到不同的内容。

   格式：关系表达式 ？ 表达式1 ：表达式2；

 	5. 运算符优先级

  6. 原码、反码、补码、<<(左移)、>>(右移)、>>>(无符号右移)

## Day04

流程控制语句$\begin{cases} 1.顺序结构 \\ 2.分支结构 \\ 3.循环结构\end{cases}$

if和switch各自的使用场景：if的第三种格式一般用于对范围的判断；switch把有限个数据一一列举出来，让我们任选其一

if语句有三种格式，第一种用于单条件判断，第二种用于双条件判断，第三种用于多条件判断。

switch语句格式：

```java
switch(表达式) {

	case 值1:
		语句体1;
    	break;
    case 值2:
        语句体2;
        break;
    ...
    default:
        语句体n+1;
        break;
}
```

应用场景：如果多个case的语句体重复了，那么我们考虑利用case穿透去简化代码。

for循环

```java
for(初始化语句; 条件判断语句; 条件控制语句){

	循环体语句;

}
```

初始化语句只执行一次，判断语句为true，循环继续；判断语句为false，循环结束

若把变量定义在循环语句中，那么当前变量仅在本次循环中有效

while循环

```java
初始化语句;
while(条件判断语句){
    循环体语句;
    条件控制语句;
}
其他语句
```

do···while循环

```java
初始化语句;
do{
    循环体语句;
    条件控制语句;
} while(条件判断语句);
```

 ## Day05

循环高级 $\begin{cases} 1.无限循环 \\ 2.跳转控制语句 \end{cases}$

`无限循环下面不能再写其他代码语句了`。

1）continue:跳过本次循环，继续执行下次循环。

2）break:结束整个循环。 

 **获取随机数**: Java类Random

**数组**：数组指的是一种容器，可以用来存储同种数据类型的多个值

**<font color=green>建议：容器的类型，和存储的数据类型保持一致</font>** 

数组的定义：格式一：数据类型 [] 数组名  范例： int [ ] array

​					格式二：数据类型 数组名[]	范例： int array[ ]

1）数组的静态初始化

完整格式：`数据类型[] 数组名 = new 数据类型[] {元素1, 元素2, 元素3...};`

简化格式：`数据类型[] 数组名 = {元素1, 元素2, 元素3...};`

2）数组的动态初始化

格式：`数据类型[] 数组名 = new 数据类型[数组长度];`

数组初始化值规律：

> 整数类型：默认初始化值为0
>
> 小数类型：默认初始化值为0.0
>
> 字符类型：默认初始化值为‘/ u0000’ 空格
>
> 布尔类型：默认初始化值为false
>
> 引用数值类型：默认初始化值 null

动态和静态的区别与使用：只明确元素个数，不明确具体数值，推荐使用动态初始化；需求中已经明确了要操作的具体数据，直接静态初始化即可

数组的常见操作：求和、求最值、交换数据、打乱数据

## Day06

方法（method）是程序中最小的执行单元。

提高代码的复用性和可维护性。

方法定义格式$\begin{cases} 1.最简单的方法定义 \\ 2.带参数的方法定义 \\ 3.带返回值的方法定义 \end{cases}$

1）最简单的方法定义

```java
//格式
public static void 方法名(){
    方法体（就是打包起来的代码）;
}
//调用
方法名();
```

2）带参数的方法定义

```java
//格式
public static void 方法名(参数1,参数2,参数3...){
    方法体
}
//调用
方法名(参数1,参数2,参数3...);
```

形参：全称形式参数，是指**方法定义**中的参数

实参：全称实际参数，**方法调用**中的参数

3）带返回值的方法定义

```java
//格式
public static 返回值类型 方法名 (参数) {
    方法体;
    return 返回值;
}
//1.直接调用
方法名(实参);
//2.赋值调用
整数类型 变量名 = 方法名 (实参);
//3.输出调用
System.out.println(方法名 (实参));
```

**方法的注意事项**

1.方法不调用就不执行

2.方法与方法之间是平级关系，不能互相嵌套定义

3.方法的编写顺序与执行顺序无关

4.方法的返回值类型为void，表示该方法没有返回值，没有返回值的方法可以省略return语句不写。如果要编写return，后面不能跟具体的数据。

5.return下面没有代码

**方法的重载**

在同一个类中，定义了多个同名的方法，这些同名的方法具有同种功能。

每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系。

> 方法传递基本数据类型的内存原理：
>
> 传递基本数据类型时，传递的是真实的数据，形参的改变，不影响实际参数的值。
>
> 传递引用数据类型时，传递的时地址值，形参的改变，影响实际参数的值。

## Day07

二维数组：数组中存数组，把数据分组管理

1）静态初始化：

```java
格式：数据类型[][] 数组名 = new 数据类型[][]{{元素1,元素2},{元素1,元素2}};

简化格式：数据类型[][] 数组名 = {{元素1,元素2},{元素1,元素2}};
```

> ```java
> 注意：每一个一维数组其实是二维数组中的元素，所以每一个一维数组之间需要用逗号隔开，最后一个一维数组后面不需要加逗号。
> ```

2）动态初始化

```java
格式：数据类型[][] 数组名 = new 数据类型[m][n];
//m表示这个二维数组可以存放多少个一维数组
//n表示每一个二维数组可以存放多少个元素
```

## Day08



**面向对象**

类：是共同特征的描述（设计图）；对象：是真实存在的具体实例

 ```java
 public class 类名 {
     1.成员变量（代表属性，一般是名词）
     2.成员方法（代表行为，一般是动词）
     3.构造器
     4.代码块
     5.内部类
 }
 ```

> 定义类的补充事项：
>
> :black_medium_small_square: 用来描述一类事物的类，专业叫做：**javabean类**。在Javabean类中，是不写main方法的。
>
> :black_medium_small_square:以前编写main方法的类，叫做**测试类**。我们可以在测试类中创建javabean类的对象并进行赋值调用。

**封装**：原则是对象代表什么，就得封装对应的数据，并提供数据对应的行为

private关键字：1）是一个权限修饰符

​							2）可以修饰成员（成员变量和成员方法）

​							3）被private修饰的成员只能在本类中才能访问

​							4）针对private修饰的成员变量，如果需要被其它类使用，提供相应的setXxx(参数)方法和getXxx()方法。

**this关键字**：解决成员变量和局部变量的二义性，本质代表方法调用者的地址值

成员变量：类中方法外的变量

局部变量：方法中的变量

就近原则

**构造方法**(构造器、构造函数):在创建对象的时候给成员变量进行赋值

```java
public class Student {
    修饰符 类名(参数) {
        方法体；
    }
}
```

构造方法注意事项

> ①构造方法的定义
>
> :black_circle:如果没有定义构造方法，系统将给出一个默认的无参数构造方法
>
> :black_circle:如果定义了构造方法，系统将不再提供默认的构造方法
>
> ②构造方法的重载
>
> :black_circle:带参构造方法，和无参数构造方法，两者方法名相同，但是参数不同、
>
> ③推荐的使用方式
>
> :black_circle:无论是否使用，都手动书写无参数构造方法，和带全部参数的构造方法。

**标准JavaBean**

①.类名需要见名知意

②.成员变量使用private修饰

③.提供至少两个构造方法

​	:black_circle:无参构造方法

​	:black_circle:带全部参数的构造方法

④.成员方法

​	:black_circle:提供每一个成员变量对应的setXxx()/getXxx()

​	:black_circle:如果还有其他行为，也需要写上



**对象内存图**

 一个对象内存图：1.加载class文件 2.声明局部变量 3.在堆内存中开辟一个空间  4.默认初始化  5.显示初始化  6.构造方法初始化  7.将堆内存中的地址值赋值给左边的局部变量 

 ## Day09

```java
//键盘录入
//第一套体系：
//nextInt();接收整数
//nextDouble;接收小数
//next();接收字符串
//遇到空格，制表符，回车就停止接收。这些符号后面的数据就不会接受了

//第二套体系：
//nextLine();接收字符串
//可以接收空格，制表符，遇到回车才停止接收数据
//注：两套体系不能混用
```

## Day10

1.API(Application Programming Interface):应用程序编程接口

**简单理解**：API就是别人已经写好的东西，我们不需要自己编写，直接使用即可。

2.创建String对象的两种方式：直接赋值和new 

|             构造方法             |               说明               |
| :------------------------------: | :------------------------------: |
|        public String（）         |   创建空白字符串，不含任何内容   |
| public String（String original） | 根据传入的字符串，创建字符串对象 |
|    public String(char[] chs)     |   根据字符数组，创建字符串对象   |
|    public String(byte[] chs)     |   根据字节数组，创建字符串对象   |

直接赋值方式不仅简单而且节约内存

3.Java的常用方法（比较）

 基本数据类型比较的是数据值，引用数据类型比较的是地址值。 

4.字符串比较

boolean equals（要比较的字符串） 完全一样结果才是true，否则为false

boolean equalsIgnoreCase(要比较的字符串)   忽略大小写的比较
